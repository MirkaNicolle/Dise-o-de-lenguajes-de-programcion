{
def handle_number(lexbuf):
    return int(lexbuf)

def handle_identifier(lexbuf):
    return lexbuf.upper()

def handle_whitespace(lexbuf):
    return None  # Simply ignore whitespaces

def handle_string(lexbuf):
    return lexbuf.strip('"')  #remueve comillas y returna the string
def handle_multiline_comment(lexbuf):
    return None  #ignora multiline comments

def handle_eof():
    raise Exception("End of Input")

}

let digit = [0-9]
let alpha = [a-zA-Z_]
let whitespace = [\s\t]
let operator = [+=\-*/><();,.{}]
let string = "\"(\\\\.|[^\"\\\\])*\""  #Match con cadenas entre comillas dobles y barras invertidas
let multiline_comment = "/\*((.|\n)*?)\*/"  #Match multiline comments

rule get_token =
    {digit}+             { handle_number(lexbuf) }            (*Easy: - Matches integers *)
  | {whitespace}+        { handle_whitespace(lexbuf) }        (*Easy: - ignora espacios en blanco *)
  | {alpha}+             { handle_identifier(lexbuf) }        (*Medium: - Match identificadores *)
  | [+-*/()]             { return lexbuf }                    (*Medium: - Match operadores y parentesis *)
  | {digit}+\.{digit}+   { return float(lexbuf) }             (*Difficult: - Match numeros con punto *)
  | {string}             { handle_string(lexbuf) }            (*Difficult: - Match con cadenas entre comillas dobles *)
  | {multiline_comment}  { handle_multiline_comment(lexbuf) } (*Difficult: - Ignora multiline comments *)
  | eof                  { handle_eof() }                     (*end of file *)

{ 

print("Lexer parsing completed.")

}